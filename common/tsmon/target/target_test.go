// Copyright 2016 The LUCI Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package target

import (
	"context"
	"testing"

	"go.chromium.org/luci/common/testing/ftt"
	"go.chromium.org/luci/common/testing/truth/assert"
	"go.chromium.org/luci/common/testing/truth/should"
)

func TestCreateTargetFromHostname(t *testing.T) {
	t.Parallel()

	ftt.Run("A target created", t, func(t *ftt.Test) {
		fl := NewFlags()
		fl.SysInfo = &SysInfo{Hostname: "test-c4", Region: "test-region"}

		t.Run("for a device with autogenerated hostname should have autogen: hostname prefix", func(t *ftt.Test) {
			fl.TargetType = DeviceType
			fl.AutoGenHostname = true
			fl.SetDefaultsFromHostname()
			target, err := NewFromFlags(&fl)
			assert.Loosely(t, err, should.BeNil)
			assert.Loosely(t, target, should.HaveType[*NetworkDevice])
			assert.Loosely(t, target.(*NetworkDevice).Hostname, should.Equal("autogen:test-c4"))
			assert.Loosely(t, target.(*NetworkDevice).Hostgroup, should.Equal("4"))
		})
		t.Run("for a device with a static hostname should not have a prefix", func(t *ftt.Test) {
			fl.TargetType = DeviceType
			fl.SetDefaultsFromHostname()
			target, err := NewFromFlags(&fl)
			assert.Loosely(t, err, should.BeNil)
			assert.Loosely(t, target, should.HaveType[*NetworkDevice])
			assert.Loosely(t, target.(*NetworkDevice).Hostname, should.Equal("test-c4"))
			assert.Loosely(t, target.(*NetworkDevice).Hostgroup, should.Equal("4"))
		})
		t.Run("for a task with autogenerated hostname should have autogen: hostname prefix", func(t *ftt.Test) {
			fl.TargetType = TaskType
			fl.TaskServiceName = "test-service"
			fl.TaskJobName = "test-job"
			fl.AutoGenHostname = true
			fl.SetDefaultsFromHostname()
			target, err := NewFromFlags(&fl)
			assert.Loosely(t, err, should.BeNil)
			assert.Loosely(t, target, should.HaveType[*Task])
			assert.Loosely(t, target.(*Task).HostName, should.Equal("autogen:test-c4"))
		})
		t.Run("for a task with a static hostname should not have a prefix", func(t *ftt.Test) {
			fl.TargetType = TaskType
			fl.TaskServiceName = "test-service"
			fl.TaskJobName = "test-job"
			fl.SetDefaultsFromHostname()
			target, err := NewFromFlags(&fl)
			assert.Loosely(t, err, should.BeNil)
			assert.Loosely(t, target, should.HaveType[*Task])
			assert.Loosely(t, target.(*Task).HostName, should.Equal("test-c4"))
		})
	})
}

func TestTargetContext(t *testing.T) {
	t.Parallel()
	ctx := context.Background()
	deviceTarget := NetworkDevice{
		Metro:     "test-metro",
		Role:      "test-role",
		Hostname:  "test-hostname",
		Hostgroup: "test-hostgroup",
	}
	taskTarget := Task{
		ServiceName: "test-service",
		JobName:     "test-job",
		DataCenter:  "test-datacenter",
		HostName:    "test-hostname",
		TaskNum:     0,
	}

	ftt.Run("Without a target context", t, func(t *ftt.Test) {
		t.Run("Get returns nil", func(t *ftt.Test) {
			assert.Loosely(t, Get(ctx, taskTarget.Type()), should.BeNil)
		})
	})
	ftt.Run("With a single target context", t, func(t *ftt.Test) {
		tctx := Set(ctx, &taskTarget)
		t.Run("Get returns the target if the type matches", func(t *ftt.Test) {
			assert.Loosely(t, Get(tctx, taskTarget.Type()), should.Equal(&taskTarget))
		})
		t.Run("Get returns nil if the type doesn't match", func(t *ftt.Test) {
			assert.Loosely(t, Get(tctx, deviceTarget.Type()), should.BeNil)
		})

		t.Run("Get returns the same target object for the same Type", func(t *ftt.Test) {
			clone := (&taskTarget).Clone().(*Task)
			clone.TaskNum += 1

			// Get should return the same target object, whichever target object
			// the type was extracted from, as long as they all are the same type
			// of target instances.
			assert.Loosely(t, Get(tctx, taskTarget.Type()), should.Equal(&taskTarget))
			assert.Loosely(t, Get(tctx, clone.Type()), should.Equal(&taskTarget))
			assert.Loosely(t, Get(tctx, (*Task)(nil).Type()), should.Equal(&taskTarget))
		})
	})

	ftt.Run("With stacked target contexts", t, func(t *ftt.Test) {
		tctx := Set(ctx, &taskTarget)
		tdctx := Set(tctx, &deviceTarget)

		t.Run("Child doesn't override the target for different types", func(t *ftt.Test) {
			assert.Loosely(t, Get(tdctx, taskTarget.Type()), should.Equal(&taskTarget))
			assert.Loosely(t, Get(tdctx, deviceTarget.Type()), should.Equal(&deviceTarget))
		})

		t.Run("Child overrides the target for the same type", func(t *ftt.Test) {
			clone := (&taskTarget).Clone().(*Task)
			clone.TaskNum += 1

			uptctx := Set(tdctx, clone)
			// The target object for DeviceType should remain the same.
			assert.Loosely(t, Get(uptctx, deviceTarget.Type()), should.Equal(&deviceTarget))
			// but the object for TaskType should have been updated.
			assert.Loosely(t, Get(uptctx, taskTarget.Type()), should.Equal(clone))
			assert.Loosely(t, Get(uptctx, taskTarget.Type()), should.NotEqual(&taskTarget))

			// the parent context should remain the same
			assert.Loosely(t, Get(tdctx, taskTarget.Type()), should.Equal(&taskTarget))
			assert.Loosely(t, Get(tdctx, deviceTarget.Type()), should.Equal(&deviceTarget))
		})
	})
}
